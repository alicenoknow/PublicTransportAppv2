{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport Map from './MapPolyfill';\nimport warning from 'warning';\nimport Intersection from './Intersection';\n\nif (!IntersectionObserver) {\n  throw new Error(['react-scroll-view requires `IntersectionObserver`.', 'You may add this polyfill to fix the issue.', '`https://github.com/w3c/IntersectionObserver/tree/master/polyfill`'].join(' '));\n}\n\nvar createBox = function createBox(observer, intersection) {\n  return {\n    observer: observer,\n    intersection: intersection\n  };\n};\n\nvar Observer = function () {\n  function Observer() {\n    _classCallCheck(this, Observer);\n\n    this._boxes = new Map();\n    this._prevScrollPos = 0;\n    this._currScrollPos = 0;\n  }\n\n  _createClass(Observer, [{\n    key: 'mount',\n    value: function mount(root) {\n      this.root = root;\n    }\n  }, {\n    key: 'observe',\n    value: function observe(target, intersection, options) {\n      var _this = this;\n\n      if (!this.root) {\n        return warning(false, 'Should call observer.mount(root) before calling observer.observe()');\n      }\n\n      if (intersection instanceof Intersection && !this._boxes.has(target)) {\n        var callback = function callback(entries) {\n          return entries.forEach(function (entry) {\n            var target = entry.target;\n\n            if (_this._boxes.has(target)) {\n              var _boxes$get = _this._boxes.get(target),\n                  _intersection = _boxes$get.intersection;\n\n              _intersection.onIntersect({\n                entry: entry\n              });\n            }\n          });\n        };\n\n        var observer = new IntersectionObserver(callback, _extends({\n          root: this.root\n        }, options));\n        var box = createBox(observer, intersection);\n\n        this._boxes.set(target, box);\n\n        observer.observe(target);\n      }\n    }\n  }, {\n    key: 'unobserve',\n    value: function unobserve(target) {\n      var box = this._boxes.get(target);\n\n      if (box) {\n        var observer = box.observer;\n        observer.unobserve(target);\n        observer.disconnect();\n\n        this._boxes.delete(target);\n      }\n    }\n  }]);\n\n  return Observer;\n}();\n\nexport default Observer;","map":null,"metadata":{},"sourceType":"module"}