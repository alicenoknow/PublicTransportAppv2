{"ast":null,"code":"import { isWebGL, createGLContext, instrumentGLContext, resizeGLContext, resetParameters } from '@luma.gl/gltools';\nimport { requestAnimationFrame, cancelAnimationFrame, Query, lumaStats, Framebuffer, log, assert } from '@luma.gl/webgl';\nimport { isBrowser } from 'probe.gl/env';\nconst isPage = isBrowser() && typeof document !== 'undefined';\nlet statIdCounter = 0;\nexport default class AnimationLoop {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      onCreateContext = opts => createGLContext(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n      gl = null,\n      glOptions = {},\n      debug = false,\n      createFramebuffer = false,\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = lumaStats.get(`animation-loop-${statIdCounter++}`)\n    } = props;\n    let {\n      useDevicePixels = true\n    } = props;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._pageLoadPromise = null;\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  delete() {\n    this.stop();\n\n    this._setDisplay(null);\n  }\n\n  setNeedsRedraw(reason) {\n    assert(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n\n    return this;\n  }\n\n  start() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._running) {\n      return this;\n    }\n\n    this._running = true;\n\n    const startPromise = this._getPageLoadPromise().then(() => {\n      if (!this._running || this._initialized) {\n        return null;\n      }\n\n      this._createWebGLContext(opts);\n\n      this._createFramebuffer();\n\n      this._startEventHandling();\n\n      this._initializeCallbackData();\n\n      this._updateCallbackData();\n\n      this._resizeCanvasDrawingBuffer();\n\n      this._resizeViewport();\n\n      this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n      this._initialized = true;\n      return this.onInitialize(this.animationProps);\n    }).then(appContext => {\n      if (this._running) {\n        this._addCallbackData(appContext || {});\n\n        if (appContext !== false) {\n          this._startLoop();\n        }\n      }\n    });\n\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n\n    return this;\n  }\n\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n\n    this._beginTimers();\n\n    this._setupFrame();\n\n    this._updateCallbackData();\n\n    this._renderFrame(this.animationProps);\n\n    this._clearNeedsRedraw();\n\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endTimers();\n\n    return this;\n  }\n\n  stop() {\n    if (this._running) {\n      this._finalizeCallbackData();\n\n      this._cancelAnimationFrame(this._animationFrameId);\n\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n\n    return this;\n  }\n\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n\n  detachTimeline() {\n    this.timeline = null;\n  }\n\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n\n    return this._nextFramePromise;\n  }\n\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    return this.gl.canvas.toDataURL();\n  }\n\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n\n  onCreateContext() {\n    return this.props.onCreateContext(...arguments);\n  }\n\n  onInitialize() {\n    return this.props.onInitialize(...arguments);\n  }\n\n  onRender() {\n    return this.props.onRender(...arguments);\n  }\n\n  onFinalize() {\n    return this.props.onFinalize(...arguments);\n  }\n\n  getHTMLControlValue(id) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const element = document.getElementById(id);\n    return element ? Number(element.value) : defaultValue;\n  }\n\n  setViewParameters() {\n    log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n\n    this._cancelAnimationFrame(this._animationFrameId);\n\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {\n        if (isPage && document.readyState === 'complete') {\n          resolve(document);\n          return;\n        }\n\n        window.addEventListener('load', () => {\n          resolve(document);\n        });\n      }) : Promise.resolve({});\n    }\n\n    return this._pageLoadPromise;\n  }\n\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _cancelAnimationFrame(animationFrameId) {\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n\n    return cancelAnimationFrame(animationFrameId);\n  }\n\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n\n      return requestAnimationFrame(renderFrameCallback);\n    }\n\n    return undefined;\n  }\n\n  _renderFrame() {\n    if (this.display) {\n      this.display._renderFrame(...arguments);\n\n      return;\n    }\n\n    this.onRender(...arguments);\n  }\n\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n\n    this._resizeViewport();\n\n    this._resizeFramebuffer();\n  }\n\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n      time: 0,\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null\n    };\n  }\n\n  _updateCallbackData() {\n    const {\n      width,\n      height,\n      aspect\n    } = this._getSizeAndAspect();\n\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n    this.animationProps.needsRedraw = this.needsRedraw;\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n    this.animationProps.tock++;\n    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n    this.animationProps._offScreen = this.offScreen;\n  }\n\n  _finalizeCallbackData() {\n    this.onFinalize(this.animationProps);\n  }\n\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n\n  _createWebGLContext(opts) {\n    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n    if (!isWebGL(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n\n    resetParameters(this.gl);\n\n    this._createInfoDiv();\n  }\n\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect() {\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n    let aspect = 1;\n    const {\n      canvas\n    } = this.gl;\n\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {\n      width,\n      height,\n      aspect\n    };\n  }\n\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      resizeGLContext(this.gl, {\n        useDevicePixels: this.useDevicePixels\n      });\n    }\n  }\n\n  _createFramebuffer() {\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new Framebuffer(this.gl);\n    }\n  }\n\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endTimers() {\n    this.cpuTime.timeEnd();\n\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.end();\n    }\n  }\n\n  _startEventHandling() {\n    const {\n      canvas\n    } = this.gl;\n\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}