{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport createStyles from './ScrollView.styles';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { isIOS, forwardRef, debounce, eventOptions } from '../util';\nimport { refType } from '../PropTypes';\nimport Observer from '../Observer';\nimport FixedState from '../FixedState';\nimport RefreshState from '../RefreshState';\nimport PullingDown from '../PullingDown';\nimport Hook from './Hook';\nimport FixedContainer from './FixedContainer';\nimport warning from 'warning';\nimport { ObserverContext, FixedContext, RefreshContext } from '../Contexts';\n\nvar ScrollView = function (_Component) {\n  _inherits(ScrollView, _Component);\n\n  function ScrollView(props) {\n    _classCallCheck(this, ScrollView);\n\n    var _this = _possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var isHorizontal = props.isHorizontal,\n        onEndReached = props.onEndReached,\n        refreshControl = props.refreshControl;\n    warning(!isHorizontal || !refreshControl, '`refreshControl` with `isHorizontal` is NOT supported, `refreshControl` will be ignored');\n    warning(!isHorizontal || !onEndReached, '`onEndReached` with `isHorizontal` is NOT supported, `onEndReached` will be ignored');\n    _this.styles = createStyles();\n    _this.observer = new Observer();\n    _this.toEmitOnScrollEnd = debounce(function (ev) {\n      var onScrollEnd = _this.props.onScrollEnd;\n      _this.isScrolling = false;\n      onScrollEnd && onScrollEnd(ev);\n    }, 100);\n    _this.fixedState = new FixedState();\n    if (props.refreshControl) _this.refreshState = new RefreshState();\n    return _this;\n  }\n\n  _createClass(ScrollView, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var dom = this.dom;\n      this.observer.mount(dom);\n      this.registerTouchEvents(dom);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var dom = this.dom;\n      this.toEmitOnScrollEnd.clearDebounce();\n      this.unregisterTouchEvents(dom);\n    }\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo() {\n      var _dom;\n\n      var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var args = this.props.isHorizontal ? [val, 0] : [0, val];\n\n      (_dom = this.dom).scrollTo.apply(_dom, args);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          style = _props.style,\n          className = _props.className,\n          contentContainerStyle = _props.contentContainerStyle,\n          contentContainerClassName = _props.contentContainerClassName,\n          children = _props.children,\n          onScrollStart = _props.onScrollStart,\n          onScrollEnd = _props.onScrollEnd,\n          onEndReached = _props.onEndReached,\n          endReachedThreshold = _props.endReachedThreshold,\n          isHorizontal = _props.isHorizontal,\n          disabled = _props.disabled,\n          refreshControl = _props.refreshControl,\n          innerRef = _props.innerRef,\n          other = _objectWithoutProperties(_props, ['style', 'className', 'contentContainerStyle', 'contentContainerClassName', 'children', 'onScrollStart', 'onScrollEnd', 'onEndReached', 'endReachedThreshold', 'isHorizontal', 'disabled', 'refreshControl', 'innerRef']),\n          styles = this.styles,\n          observer = this.observer,\n          fixedState = this.fixedState,\n          refreshState = this.refreshState;\n\n      var direction = isHorizontal ? 'horizontal' : 'vertical';\n      return React.createElement(ObserverContext.Provider, {\n        value: observer\n      }, React.createElement(FixedContext.Provider, {\n        value: fixedState\n      }, React.createElement(RefreshContext.Provider, {\n        value: refreshState\n      }, React.createElement('div', {\n        style: styles.container(style),\n        className: className\n      }, React.createElement('div', _extends({}, other, {\n        style: styles.main(direction, disabled),\n        ref: this.scrollViewRef,\n        onScroll: this.handleScroll\n      }), !isHorizontal && refreshControl, React.createElement('div', {\n        style: contentContainerStyle,\n        className: contentContainerClassName\n      }, children), isIOS && React.createElement('div', {\n        style: styles.background(direction)\n      }), !isHorizontal && React.createElement(Hook, {\n        style: styles.endHook(endReachedThreshold),\n        onEnter: this.handleEndEnter\n      })), React.createElement(FixedContainer, {\n        style: styles.fixedContainer(contentContainerStyle)\n      }, fixedState.children)))));\n    }\n  }]);\n\n  return ScrollView;\n}(Component);\n\nScrollView.propTypes = {\n  style: PropTypes.object,\n  className: PropTypes.string,\n  contentContainerStyle: PropTypes.object,\n  contentContainerClassName: PropTypes.string,\n  children: PropTypes.node,\n  onScrollStart: PropTypes.func,\n  onScroll: PropTypes.func,\n  onScrollEnd: PropTypes.func,\n  onEndReached: PropTypes.func,\n  endReachedThreshold: PropTypes.number,\n  isHorizontal: PropTypes.bool,\n  innerRef: refType,\n  disabled: PropTypes.bool,\n  refreshControl: PropTypes.node\n};\nScrollView.defaultProps = {\n  endReachedThreshold: 0,\n  isHorizontal: false,\n  disabled: false\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.scrollViewRef = function (dom) {\n    forwardRef(_this2.props.innerRef, dom);\n    _this2.dom = dom;\n  };\n\n  this.registerTouchEvents = function (dom) {\n    if (!_this2.refreshState) return;\n    _this2.pullingDown = new PullingDown(_this2.dom);\n    dom.addEventListener('touchstart', _this2.handleTouchStart, eventOptions);\n  };\n\n  this.unregisterTouchEvents = function (dom) {\n    if (!_this2.refreshState) return;\n    dom.removeEventListener('touchstart', _this2.handleTouchStart, eventOptions);\n  };\n\n  this.handleEndEnter = function () {\n    var onEndReached = _this2.props.onEndReached;\n    if (onEndReached) onEndReached();\n  };\n\n  this.handleScroll = function (ev) {\n    var _props2 = _this2.props,\n        onScrollStart = _props2.onScrollStart,\n        onScroll = _props2.onScroll,\n        isScrolling = _this2.isScrolling;\n\n    if (!isScrolling) {\n      _this2.isScrolling = true;\n      onScrollStart && onScrollStart(ev);\n    }\n\n    onScroll && onScroll(ev);\n\n    _this2.toEmitOnScrollEnd(ev);\n  };\n\n  this.handleTouchStart = function (ev) {\n    var dom = _this2.dom;\n    _this2.y0 = ev.touches[0].clientY;\n    dom.addEventListener('touchmove', _this2.handleTouchMove, eventOptions);\n    dom.addEventListener('touchend', _this2.handleTouchEnd, eventOptions);\n  };\n\n  this.handleTouchMove = function (ev) {\n    var touchClient = ev.touches[0];\n    var dy = touchClient.clientY - _this2.y0;\n\n    if (!_this2.pullingDown.isActive) {\n      if (_this2.dom.scrollTop <= 0) {\n        if (dy > 0) {\n          _this2.pullingDown.start();\n\n          _this2.refreshState.call('disableTransition');\n        }\n      } else {\n        _this2.y0 = touchClient.clientY;\n      }\n    } else if (dy <= 0) {\n      _this2.refreshState.call('setHeight', 0);\n\n      _this2.pullingDown.stop();\n    }\n\n    if (_this2.pullingDown.isActive) {\n      _this2.refreshState.call('setHeight', dy);\n    }\n  };\n\n  this.handleTouchEnd = function () {\n    var dom = _this2.dom;\n    _this2.y0 = 0;\n\n    if (_this2.pullingDown.isActive) {\n      _this2.refreshState.call('attemptToRefresh');\n\n      _this2.pullingDown.stop();\n    }\n\n    dom.removeEventListener('touchmove', _this2.handleTouchMove, eventOptions);\n    dom.removeEventListener('touchend', _this2.handleTouchEnd, eventOptions);\n  };\n};\n\nexport default ScrollView;","map":null,"metadata":{},"sourceType":"module"}