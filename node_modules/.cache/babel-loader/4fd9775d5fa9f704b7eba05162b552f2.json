{"ast":null,"code":"import { isBuffer, bufferToArrayBuffer } from './buffer-utils';\nexport function toArrayBuffer(data) {\n  if (isBuffer(data)) {\n    return bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n  const result = new Uint8Array(byteLength);\n  let offset = 0;\n\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  return result.buffer;\n}\nexport function concatenateTypedArrays() {\n  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    typedArrays[_key2] = arguments[_key2];\n  }\n\n  const arrays = typedArrays;\n  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;\n\n  if (!TypedArrayConstructor) {\n    throw new Error('\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types');\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n\n  return result;\n}\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}","map":null,"metadata":{},"sourceType":"module"}