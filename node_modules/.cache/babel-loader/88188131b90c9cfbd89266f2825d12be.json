{"ast":null,"code":"import Resource from './resource';\nimport Buffer from './buffer';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { getScratchArray, fillArray } from '../utils/array-utils-flat';\nimport { assert } from '../utils/assert';\nimport { getBrowser } from 'probe.gl';\nconst ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';\nexport default class VertexArrayObject extends Resource {\n  static isSupported(gl) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.constantAttributeZero) {\n      return isWebGL2(gl) || getBrowser() === 'Chrome';\n    }\n\n    return true;\n  }\n\n  static getDefaultArray(gl) {\n    gl.luma = gl.luma || {};\n\n    if (!gl.luma.defaultVertexArray) {\n      gl.luma.defaultVertexArray = new VertexArrayObject(gl, {\n        handle: null,\n        isDefaultArray: true\n      });\n    }\n\n    return gl.luma.defaultVertexArray;\n  }\n\n  static getMaxAttributes(gl) {\n    VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);\n    return VertexArrayObject.MAX_ATTRIBUTES;\n  }\n\n  static setConstant(gl, location, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        VertexArrayObject._setConstantFloatArray(gl, location, array);\n\n        break;\n\n      case Int32Array:\n        VertexArrayObject._setConstantIntArray(gl, location, array);\n\n        break;\n\n      case Uint32Array:\n        VertexArrayObject._setConstantUintArray(gl, location, array);\n\n        break;\n\n      default:\n        assert(false);\n    }\n  }\n\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = opts.id || opts.program && opts.program.id;\n    super(gl, Object.assign({}, opts, {\n      id\n    }));\n    this.buffer = null;\n    this.bufferValue = null;\n    this.isDefaultArray = opts.isDefaultArray || false;\n    this.gl2 = gl;\n    this.initialize(opts);\n    Object.seal(this);\n  }\n\n  delete() {\n    super.delete();\n\n    if (this.buffer) {\n      this.buffer.delete();\n    }\n\n    return this;\n  }\n\n  get MAX_ATTRIBUTES() {\n    return VertexArrayObject.getMaxAttributes(this.gl);\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.setProps(props);\n  }\n\n  setProps(props) {\n    return this;\n  }\n\n  setElementBuffer() {\n    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assert(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);\n    this.bind(() => {\n      this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);\n    });\n    return this;\n  }\n\n  setBuffer(location, buffer, accessor) {\n    if (buffer.target === 34963) {\n      return this.setElementBuffer(buffer, accessor);\n    }\n\n    const {\n      size,\n      type,\n      stride,\n      offset,\n      normalized,\n      integer,\n      divisor\n    } = accessor;\n    const {\n      gl,\n      gl2\n    } = this;\n    location = Number(location);\n    this.bind(() => {\n      gl.bindBuffer(34962, buffer.handle);\n\n      if (integer) {\n        assert(isWebGL2(gl));\n        gl2.vertexAttribIPointer(location, size, type, stride, offset);\n      } else {\n        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n      }\n\n      gl.enableVertexAttribArray(location);\n      gl2.vertexAttribDivisor(location, divisor || 0);\n    });\n    return this;\n  }\n\n  enable(location) {\n    let enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const disablingAttributeZero = !enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {\n      constantAttributeZero: true\n    });\n\n    if (!disablingAttributeZero) {\n      location = Number(location);\n      this.bind(() => enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));\n    }\n\n    return this;\n  }\n\n  getConstantBuffer(elementCount, value) {\n    const constantValue = this._normalizeConstantArrayValue(value);\n\n    const byteLength = constantValue.byteLength * elementCount;\n    const length = constantValue.length * elementCount;\n    let updateNeeded = !this.buffer;\n    this.buffer = this.buffer || new Buffer(this.gl, byteLength);\n    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);\n    updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);\n\n    if (updateNeeded) {\n      const typedArray = getScratchArray(value.constructor, length);\n      fillArray({\n        target: typedArray,\n        source: constantValue,\n        start: 0,\n        count: length\n      });\n      this.buffer.subData(typedArray);\n      this.bufferValue = value;\n    }\n\n    return this.buffer;\n  }\n\n  _normalizeConstantArrayValue(arrayValue) {\n    if (Array.isArray(arrayValue)) {\n      return new Float32Array(arrayValue);\n    }\n\n    return arrayValue;\n  }\n\n  _compareConstantArrayValues(v1, v2) {\n    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {\n      return false;\n    }\n\n    for (let i = 0; i < v1.length; ++i) {\n      if (v1[i] !== v2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _setConstantFloatArray(gl, location, array) {\n    switch (array.length) {\n      case 1:\n        gl.vertexAttrib1fv(location, array);\n        break;\n\n      case 2:\n        gl.vertexAttrib2fv(location, array);\n        break;\n\n      case 3:\n        gl.vertexAttrib3fv(location, array);\n        break;\n\n      case 4:\n        gl.vertexAttrib4fv(location, array);\n        break;\n\n      default:\n        assert(false);\n    }\n  }\n\n  static _setConstantIntArray(gl, location, array) {\n    assert(isWebGL2(gl));\n\n    switch (array.length) {\n      case 1:\n        gl.vertexAttribI1iv(location, array);\n        break;\n\n      case 2:\n        gl.vertexAttribI2iv(location, array);\n        break;\n\n      case 3:\n        gl.vertexAttribI3iv(location, array);\n        break;\n\n      case 4:\n        gl.vertexAttribI4iv(location, array);\n        break;\n\n      default:\n        assert(false);\n    }\n  }\n\n  static _setConstantUintArray(gl, location, array) {\n    assert(isWebGL2(gl));\n\n    switch (array.length) {\n      case 1:\n        gl.vertexAttribI1uiv(location, array);\n        break;\n\n      case 2:\n        gl.vertexAttribI2uiv(location, array);\n        break;\n\n      case 3:\n        gl.vertexAttribI3uiv(location, array);\n        break;\n\n      case 4:\n        gl.vertexAttribI4uiv(location, array);\n        break;\n\n      default:\n        assert(false);\n    }\n  }\n\n  _createHandle() {\n    const gl2 = this.gl;\n    return gl2.createVertexArray();\n  }\n\n  _deleteHandle(handle) {\n    this.gl2.deleteVertexArray(handle);\n    return [this.elements];\n  }\n\n  _bindHandle(handle) {\n    this.gl2.bindVertexArray(handle);\n  }\n\n  _getParameter(pname, _ref) {\n    let {\n      location\n    } = _ref;\n    assert(Number.isFinite(location));\n    return this.bind(() => {\n      switch (pname) {\n        case 34373:\n          return this.gl.getVertexAttribOffset(location, pname);\n\n        default:\n          return this.gl.getVertexAttrib(location, pname);\n      }\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}