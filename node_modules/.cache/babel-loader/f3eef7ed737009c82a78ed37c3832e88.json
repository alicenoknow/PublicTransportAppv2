{"ast":null,"code":"import { assert } from '../utils/assert';\nimport { isWebGL2 } from '../utils/webgl-checks';\nimport { getParameterPolyfill } from './get-parameter-polyfill';\nconst OES_vertex_array_object = 'OES_vertex_array_object';\nconst ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';\nconst WEBGL_draw_buffers = 'WEBGL_draw_buffers';\nconst EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';\nconst EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';\nconst ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';\n\nfunction getExtensionData(gl, extension) {\n  return {\n    webgl2: isWebGL2(gl),\n    ext: gl.getExtension(extension)\n  };\n}\n\nexport const WEBGL2_CONTEXT_POLYFILLS = {\n  [OES_vertex_array_object]: {\n    meta: {\n      suffix: 'OES'\n    },\n    createVertexArray: () => {\n      assert(false, ERR_VAO_NOT_SUPPORTED);\n    },\n    deleteVertexArray: () => {},\n    bindVertexArray: () => {},\n    isVertexArray: () => false\n  },\n  [ANGLE_instanced_arrays]: {\n    meta: {\n      suffix: 'ANGLE'\n    },\n\n    vertexAttribDivisor(location, divisor) {\n      assert(divisor === 0, 'WebGL instanced rendering not supported');\n    },\n\n    drawElementsInstanced: () => {},\n    drawArraysInstanced: () => {}\n  },\n  [WEBGL_draw_buffers]: {\n    meta: {\n      suffix: 'WEBGL'\n    },\n    drawBuffers: () => {\n      assert(false);\n    }\n  },\n  [EXT_disjoint_timer_query]: {\n    meta: {\n      suffix: 'EXT'\n    },\n    createQuery: () => {\n      assert(false);\n    },\n    deleteQuery: () => {\n      assert(false);\n    },\n    beginQuery: () => {\n      assert(false);\n    },\n    endQuery: () => {},\n\n    getQuery(handle, pname) {\n      return this.getQueryObject(handle, pname);\n    },\n\n    getQueryParameter(handle, pname) {\n      return this.getQueryObject(handle, pname);\n    },\n\n    getQueryObject: () => {}\n  }\n};\nexport const WEBGL2_CONTEXT_OVERRIDES = {\n  readBuffer: (gl, originalFunc, attachment) => {\n    if (isWebGL2(gl)) {\n      originalFunc(attachment);\n    } else {}\n  },\n  getVertexAttrib: (gl, originalFunc, location, pname) => {\n    const {\n      webgl2,\n      ext\n    } = getExtensionData(gl, ANGLE_instanced_arrays);\n    let result;\n\n    switch (pname) {\n      case 35069:\n        result = !webgl2 ? false : undefined;\n        break;\n\n      case 35070:\n        result = !webgl2 && !ext ? 0 : undefined;\n        break;\n\n      default:\n    }\n\n    return result !== undefined ? result : originalFunc(location, pname);\n  },\n  getProgramParameter: (gl, originalFunc, program, pname) => {\n    if (!isWebGL2(gl)) {\n      switch (pname) {\n        case 35967:\n          return 35981;\n\n        case 35971:\n          return 0;\n\n        case 35382:\n          return 0;\n\n        default:\n      }\n    }\n\n    return originalFunc(program, pname);\n  },\n  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {\n    if (!isWebGL2(gl)) {\n      switch (pname) {\n        case 32937:\n          return new Int32Array([0]);\n\n        default:\n      }\n    }\n\n    return gl.getInternalformatParameter(target, format, pname);\n  },\n\n  getTexParameter(gl, originalFunc, target, pname) {\n    switch (pname) {\n      case 34046:\n        const {\n          extensions\n        } = gl.luma;\n        const ext = extensions[EXT_texture_filter_anisotropic];\n        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;\n        break;\n\n      default:\n    }\n\n    return originalFunc(target, pname);\n  },\n\n  getParameter: getParameterPolyfill,\n\n  hint(gl, originalFunc, pname, value) {\n    return originalFunc(pname, value);\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}