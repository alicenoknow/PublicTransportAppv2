{"ast":null,"code":"import { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { load } from '@loaders.gl/core';\nimport { createIterable } from '@deck.gl/core';\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9987,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\nfunction resizeImage(ctx, imageData, width, height) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\nfunction resizeTexture(gl, texture, width, height) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n  const newTexture = cloneTextureFrom(texture, {\n    width,\n    height\n  });\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture.delete();\n  return newTexture;\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = { ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\nexport function buildMapping(_ref) {\n  let {\n    icons,\n    buffer,\n    mapping = {},\n    xOffset = 0,\n    yOffset = 0,\n    rowHeight = 0,\n    canvasWidth\n  } = _ref;\n  let columns = [];\n\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = { ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n\n  return icons;\n}\nexport default class IconManager {\n  constructor(gl, _ref2) {\n    let {\n      onUpdate = noop,\n      onError = noop\n    } = _ref2;\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n    this._loadOptions = null;\n    this._getIcon = null;\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    this._pendingCount = 0;\n    this._autoPacking = false;\n    this._xOffset = 0;\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n  }\n\n  finalize() {\n    var _this$_texture;\n\n    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps(_ref3) {\n    let {\n      loadOptions,\n      autoPacking,\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon\n    } = _ref3;\n\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (getIcon) {\n      this._getIcon = getIcon;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._updateIconAtlas(iconAtlas);\n    }\n\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._updateAutoPacking(data);\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  _updateIconAtlas(iconAtlas) {\n    var _this$_texture2;\n\n    (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();\n    this._texture = null;\n    this._externalTexture = iconAtlas;\n    this.onUpdate();\n  }\n\n  _updateAutoPacking(data) {\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight);\n      }\n\n      this.onUpdate();\n\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d');\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const {\n          x,\n          y,\n          width,\n          height\n        } = this._mapping[id];\n        const data = resizeImage(ctx, imageData, width, height);\n\n        this._texture.setSubImageData({\n          data,\n          x,\n          y,\n          width,\n          height\n        });\n\n        this._texture.generateMipmap();\n\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}