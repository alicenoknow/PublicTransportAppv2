{"ast":null,"code":"import { assert, concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { normalizeOptions } from '../loader-utils/option-utils';\nimport { getLoaderContext } from '../loader-utils/loader-context';\nimport { getAsyncIterableFromData } from '../loader-utils/get-data';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { selectLoader } from './select-loader';\nimport { parse } from './parse';\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context === 'object');\n\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n\n  data = await data;\n  options = options || {};\n  const {\n    url\n  } = getResourceUrlAndType(data);\n  const loader = await selectLoader(data, loaders, options);\n\n  if (!loader) {\n    return null;\n  }\n\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({\n    url,\n    parseInBatches,\n    parse,\n    loaders: loaders\n  }, options, context);\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\nasync function parseToOutputIterator(loader, data, options, context) {\n  const inputIterator = await getAsyncIterableFromData(data, options);\n  const transformedIterator = await applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);\n\n  if (loader.parseInBatches) {\n    return loader.parseInBatches(transformedIterator, options, context);\n  }\n\n  async function* parseChunkInBatches() {\n    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n    const parsedData = await parse(arrayBuffer, loader, { ...options,\n      mimeType: loader.mimeTypes[0]\n    }, context);\n    const batch = {\n      mimeType: loader.mimeTypes[0],\n      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',\n      batchType: 'data',\n      data: parsedData,\n      length: Array.isArray(parsedData) ? parsedData.length : 1\n    };\n    yield batch;\n  }\n\n  return parseChunkInBatches();\n}\n\nasync function applyInputTransforms(inputIterator) {\n  let transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let iteratorChain = inputIterator;\n\n  for await (const transformBatches of transforms) {\n    iteratorChain = transformBatches(iteratorChain);\n  }\n\n  return iteratorChain;\n}","map":null,"metadata":{},"sourceType":"module"}