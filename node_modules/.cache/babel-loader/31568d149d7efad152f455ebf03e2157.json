{"ast":null,"code":"const _excluded = [\"id\", \"value\", \"onChange\", \"onSelect\", \"onToggle\", \"onKeyDown\", \"onKeyPress\", \"onCurrentDateChange\", \"inputProps\", \"calendarProps\", \"timeInputProps\", \"popupProps\", \"autoFocus\", \"tabIndex\", \"disabled\", \"readOnly\", \"className\", \"valueFormat\", \"valueDisplayFormat\", \"valueEditFormat\", \"containerClassName\", \"name\", \"selectIcon\", \"placeholder\", \"includeTime\", \"min\", \"max\", \"open\", \"dropUp\", \"parse\", \"messages\", \"formats\", \"currentDate\", \"popupTransition\", \"popupComponent\", \"timePrecision\", \"aria-labelledby\", \"aria-describedby\"];\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport cn from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { useImperativeHandle, useRef, useCallback } from 'react';\nimport { useUncontrolled } from 'uncontrollable';\nimport Calendar from './Calendar';\nimport DatePickerInput from './DatePickerInput';\nimport { calendar } from './Icon';\nimport { useLocalizer } from './Localization';\nimport BasePopup from './Popup';\nimport TimeInput from './TimeInput';\nimport Widget from './Widget';\nimport WidgetPicker from './WidgetPicker';\nimport dates from './dates';\nimport useDropdownToggle from './useDropdownToggle';\nimport useTabTrap from './useTabTrap';\nimport useFocusManager from './useFocusManager';\nimport { notify, useFirstFocusedRender, useInstanceId } from './WidgetHelpers';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport InputAddon from './InputAddon';\nlet propTypes = {\n  /**\n   * @example ['valuePicker', [ ['new Date()', null] ]]\n   */\n  value: PropTypes.instanceOf(Date),\n\n  /**\n   * @example ['onChangePicker', [ ['new Date()', null] ]]\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * @example ['openDate']\n   */\n  open: PropTypes.bool,\n  onToggle: PropTypes.func,\n\n  /**\n   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).\n   */\n  currentDate: PropTypes.instanceOf(Date),\n\n  /**\n   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.\n   */\n  onCurrentDateChange: PropTypes.func,\n  onSelect: PropTypes.func,\n\n  /**\n   * The minimum Date that can be selected. Min only limits selection, it doesn't constrain the date values that\n   * can be typed or pasted into the widget. If you need this behavior you can constrain values via\n   * the `onChange` handler.\n   *\n   * @example ['prop', ['min', 'new Date()']]\n   */\n  min: PropTypes.instanceOf(Date),\n\n  /**\n   * The maximum Date that can be selected. Max only limits selection, it doesn't constrain the date values that\n   * can be typed or pasted into the widget. If you need this behavior you can constrain values via\n   * the `onChange` handler.\n   *\n   * @example ['prop', ['max', 'new Date()']]\n   */\n  max: PropTypes.instanceOf(Date),\n\n  /**\n   * A formatting options used to display the date value. This is a shorthand for\n   * setting both `valueDisplayFormat` and `valueEditFormat`.\n   */\n  valueFormat: PropTypes.any,\n\n  /**\n   * A formatting options used to display the date value. For more information about formats\n   * visit the [Localization page](./localization)\n   *\n   * ```tsx live\n   * import { DatePicker } from 'react-widgets';\n   *\n   * <DatePicker\n   *   defaultValue={new Date()}\n   *   valueDisplayFormat={{ dateStyle: \"medium\" }}\n   * />\n   * ```\n   */\n  valueDisplayFormat: PropTypes.any,\n\n  /**\n   * A formatting options used while the date input has focus. Useful for showing a simpler format for inputing.\n   * For more information about formats visit the [Localization page](./localization)\n   *\n   * ```tsx live\n   * import { DatePicker } from 'react-widgets';\n   *\n   * <DatePicker\n   *   defaultValue={new Date()}\n   *   valueEditFormat={{ dateStyle: \"short\" }}\n   *   valueDisplayFormat={{ dateStyle: \"medium\" }}\n   * />\n   * ```\n   */\n  valueEditFormat: PropTypes.any,\n\n  /**\n   * Enable the time list component of the picker.\n   */\n  includeTime: PropTypes.bool,\n  timePrecision: PropTypes.oneOf(['minutes', 'seconds', 'milliseconds']),\n  timeInputProps: PropTypes.object,\n\n  /** Specify the element used to render the calendar dropdown icon. */\n  selectIcon: PropTypes.node,\n  dropUp: PropTypes.bool,\n  popupTransition: PropTypes.elementType,\n  placeholder: PropTypes.string,\n  name: PropTypes.string,\n  autoFocus: PropTypes.bool,\n\n  /**\n   * @example ['disabled', ['new Date()']]\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * @example ['readOnly', ['new Date()']]\n   */\n  readOnly: PropTypes.bool,\n\n  /**\n   * Determines how the widget parses the typed date string into a Date object. You can provide an array of formats to try,\n   * or provide a function that returns a date to handle parsing yourself. When `parse` is unspecified and\n   * the `format` prop is a `string` parse will automatically use that format as its default.\n   */\n  parse: PropTypes.oneOfType([PropTypes.any, PropTypes.func]),\n\n  /** @ignore */\n  tabIndex: PropTypes.any,\n\n  /** @ignore */\n  'aria-labelledby': PropTypes.string,\n\n  /** @ignore */\n  'aria-describedby': PropTypes.string,\n\n  /** @ignore */\n  localizer: PropTypes.any,\n  onKeyDown: PropTypes.func,\n  onKeyPress: PropTypes.func,\n  onBlur: PropTypes.func,\n  onFocus: PropTypes.func,\n\n  /** Adds a css class to the input container element. */\n  containerClassName: PropTypes.string,\n  calendarProps: PropTypes.object,\n  inputProps: PropTypes.object,\n  messages: PropTypes.shape({\n    dateButton: PropTypes.string\n  })\n};\nconst defaultProps = Object.assign({}, Calendar.defaultProps, {\n  min: new Date(1900, 0, 1),\n  max: new Date(2099, 11, 31),\n  selectIcon: calendar,\n  formats: {}\n});\n/**\n * ---\n * subtitle: DatePicker, TimePicker\n * localized: true\n * shortcuts:\n *   - { key: alt + down arrow, label:  open calendar or time }\n *   - { key: alt + up arrow, label: close calendar or time }\n *   - { key: down arrow, label: move focus to next item }\n *   - { key: up arrow, label: move focus to previous item }\n *   - { key: home, label: move focus to first item }\n *   - { key: end, label: move focus to last item }\n *   - { key: enter, label: select focused item }\n *   - { key: any key, label: search list for item starting with key }\n * ---\n *\n * @public\n * @extends Calendar\n */\n\nconst DatePicker = /*#__PURE__*/React.forwardRef((uncontrolledProps, outerRef) => {\n  const _useUncontrolled = useUncontrolled(uncontrolledProps, {\n    open: 'onToggle',\n    value: 'onChange',\n    currentDate: 'onCurrentDateChange'\n  }),\n        {\n    id,\n    value,\n    onChange,\n    onSelect,\n    onToggle,\n    onKeyDown,\n    onKeyPress,\n    onCurrentDateChange,\n    inputProps,\n    calendarProps,\n    timeInputProps,\n    popupProps,\n    autoFocus,\n    tabIndex,\n    disabled,\n    readOnly,\n    className,\n    // @ts-ignore\n    valueFormat,\n    valueDisplayFormat = valueFormat,\n    valueEditFormat = valueFormat,\n    containerClassName,\n    name,\n    selectIcon,\n    placeholder,\n    includeTime = false,\n    min,\n    max,\n    open,\n    dropUp,\n    parse,\n    messages,\n    formats,\n    currentDate,\n    popupTransition,\n    popupComponent: Popup = BasePopup,\n    timePrecision,\n    'aria-labelledby': ariaLabelledby,\n    'aria-describedby': ariaDescribedby\n  } = _useUncontrolled,\n        elementProps = _objectWithoutPropertiesLoose(_useUncontrolled, _excluded);\n\n  const localizer = useLocalizer(messages, formats);\n  const ref = useRef(null);\n  const calRef = useRef(null);\n  const tabTrap = useTabTrap(calRef);\n  const inputId = useInstanceId(id, '_input');\n  const dateId = useInstanceId(id, '_date');\n  const currentFormat = includeTime ? 'datetime' : 'date';\n  const toggle = useDropdownToggle(open, onToggle);\n  const [focusEvents, focused] = useFocusManager(ref, uncontrolledProps, {\n    didHandle(focused) {\n      if (!focused) {\n        toggle.close();\n        tabTrap.stop();\n      } else if (open) {\n        tabTrap.focus();\n      }\n    }\n\n  });\n  const dateParser = useCallback(str => {\n    var _localizer$parseDate, _ref;\n\n    if (typeof parse == 'function') {\n      var _parse;\n\n      return (_parse = parse(str, localizer)) != null ? _parse : null;\n    }\n\n    return (_localizer$parseDate = localizer.parseDate(str, (_ref = parse != null ? parse : valueEditFormat) != null ? _ref : valueDisplayFormat)) != null ? _localizer$parseDate : null;\n  }, [localizer, parse, valueDisplayFormat, valueEditFormat]);\n  /**\n   * Handlers\n   */\n\n  const handleChange = useEventCallback((date, str, constrain) => {\n    if (readOnly || disabled) return;\n    if (constrain) date = inRangeValue(date);\n\n    if (onChange) {\n      if (date == null || value == null) {\n        if (date != value //eslint-disable-line eqeqeq\n        ) onChange(date, str);\n      } else if (!dates.eq(date, value)) {\n        onChange(date, str);\n      }\n    }\n  });\n  const handleKeyDown = useEventCallback(e => {\n    if (readOnly) return;\n    notify(onKeyDown, [e]);\n    if (e.defaultPrevented) return;\n\n    if (e.key === 'Escape' && open) {\n      toggle.close();\n    } else if (e.altKey) {\n      if (e.key === 'ArrowDown') {\n        e.preventDefault();\n        toggle.open();\n      } else if (e.key === 'ArrowUp') {\n        e.preventDefault();\n        toggle.close();\n      }\n    }\n  });\n  const handleKeyPress = useEventCallback(e => {\n    notify(onKeyPress, [e]);\n    if (e.defaultPrevented) return;\n  });\n  const handleDateSelect = useEventCallback(date => {\n    var _ref$current;\n\n    let dateTime = dates.merge(date, value, currentDate);\n    let dateStr = formatDate(date);\n    if (!includeTime) toggle.close();\n    notify(onSelect, [dateTime, dateStr]);\n    handleChange(dateTime, dateStr, true);\n    (_ref$current = ref.current) == null ? void 0 : _ref$current.focus();\n  });\n  const handleTimeChange = useEventCallback(date => {\n    handleChange(date, formatDate(date), true);\n  });\n  const handleCalendarClick = useEventCallback(e => {\n    if (readOnly || disabled) return; // prevents double clicks when in a <label>\n\n    e.preventDefault();\n    toggle();\n  });\n\n  const handleOpening = () => {\n    tabTrap.start();\n    requestAnimationFrame(() => {\n      tabTrap.focus();\n    });\n  };\n\n  const handleClosing = () => {\n    tabTrap.stop();\n    if (focused) focus();\n  };\n  /**\n   * Methods\n   */\n\n\n  function focus() {\n    var _calRef$current, _ref$current2;\n\n    if (open) (_calRef$current = calRef.current) == null ? void 0 : _calRef$current.focus();else (_ref$current2 = ref.current) == null ? void 0 : _ref$current2.focus();\n  }\n\n  function inRangeValue(value) {\n    if (value == null) return value;\n    return dates.max(dates.min(value, max), min);\n  }\n\n  function formatDate(date) {\n    return date instanceof Date && !isNaN(date.getTime()) ? localizer.formatDate(date, currentFormat) : '';\n  }\n\n  useImperativeHandle(outerRef, () => ({\n    focus\n  }));\n  let shouldRenderList = useFirstFocusedRender(focused, open);\n  const inputReadOnly = (inputProps == null ? void 0 : inputProps.readOnly) != null ? inputProps == null ? void 0 : inputProps.readOnly : readOnly;\n  return /*#__PURE__*/React.createElement(Widget, _extends({}, elementProps, {\n    defaultValue: undefined,\n    open: !!open,\n    dropUp: dropUp,\n    focused: focused,\n    disabled: disabled,\n    readOnly: readOnly,\n    onKeyDown: handleKeyDown,\n    onKeyPress: handleKeyPress\n  }, focusEvents, {\n    className: cn(className, 'rw-date-picker')\n  }), /*#__PURE__*/React.createElement(WidgetPicker, {\n    className: containerClassName\n  }, /*#__PURE__*/React.createElement(DatePickerInput, _extends({}, inputProps, {\n    id: inputId,\n    ref: ref,\n    role: \"combobox\",\n    name: name,\n    value: value,\n    tabIndex: tabIndex,\n    autoFocus: autoFocus,\n    placeholder: placeholder,\n    disabled: disabled,\n    readOnly: inputReadOnly,\n    formatter: currentFormat,\n    displayFormat: valueDisplayFormat,\n    editFormat: valueEditFormat,\n    editing: focused,\n    localizer: localizer,\n    parse: dateParser,\n    onChange: handleChange,\n    \"aria-haspopup\": true,\n    \"aria-labelledby\": ariaLabelledby,\n    \"aria-describedby\": ariaDescribedby,\n    \"aria-expanded\": !!open,\n    \"aria-owns\": dateId\n  })), /*#__PURE__*/React.createElement(InputAddon, {\n    icon: selectIcon,\n    label: localizer.messages.dateButton(),\n    disabled: disabled || readOnly,\n    onClick: handleCalendarClick\n  })), !!shouldRenderList && /*#__PURE__*/React.createElement(Popup, _extends({}, popupProps, {\n    dropUp: dropUp,\n    open: open,\n    role: \"dialog\",\n    ref: calRef,\n    id: dateId,\n    className: \"rw-calendar-popup\",\n    transition: popupTransition,\n    onEntering: handleOpening,\n    onExited: handleClosing\n  }), /*#__PURE__*/React.createElement(Calendar, _extends({\n    min: min,\n    max: max,\n    bordered: false\n  }, calendarProps, {\n    messages: Object.assign({}, messages, calendarProps == null ? void 0 : calendarProps.messages),\n    tabIndex: -1,\n    value: value,\n    autoFocus: false,\n    onChange: handleDateSelect,\n    currentDate: currentDate,\n    onCurrentDateChange: onCurrentDateChange,\n    \"aria-hidden\": !open,\n    \"aria-live\": \"polite\",\n    \"aria-labelledby\": inputId\n  })), includeTime && /*#__PURE__*/React.createElement(TimeInput, _extends({}, timeInputProps, {\n    value: value,\n    precision: timePrecision,\n    onChange: handleTimeChange,\n    datePart: currentDate\n  }))));\n});\nDatePicker.displayName = 'DatePicker';\nDatePicker.propTypes = propTypes;\nDatePicker.defaultProps = defaultProps;\nexport default DatePicker;","map":null,"metadata":{},"sourceType":"module"}