{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nexport default class BrowserFileSystem {\n  constructor(files, options) {\n    _defineProperty(this, \"_fetch\", void 0);\n\n    _defineProperty(this, \"files\", {});\n\n    _defineProperty(this, \"lowerCaseFiles\", {});\n\n    _defineProperty(this, \"usedFiles\", {});\n\n    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;\n\n    for (let i = 0; i < files.length; ++i) {\n      const file = files[i];\n      this.files[file.name] = file;\n      this.lowerCaseFiles[file.name.toLowerCase()] = file;\n      this.usedFiles[file.name] = false;\n    }\n\n    this.fetch = this.fetch.bind(this);\n  }\n\n  async fetch(path, options) {\n    if (path.includes('://')) {\n      return this._fetch(path, options);\n    }\n\n    const file = this.files[path];\n\n    if (!file) {\n      return new Response(path, {\n        status: 400,\n        statusText: 'NOT FOUND'\n      });\n    }\n\n    const headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);\n    const range = headers.get('Range');\n    const bytes = range && /bytes=($1)-($2)/.exec(range);\n\n    if (bytes) {\n      const start = parseInt(bytes[1]);\n      const end = parseInt(bytes[2]);\n      const data = await file.slice(start, end).arrayBuffer();\n      const response = new Response(data);\n      Object.defineProperty(response, 'url', {\n        value: path\n      });\n      return response;\n    }\n\n    const response = new Response(file);\n    Object.defineProperty(response, 'url', {\n      value: path\n    });\n    return response;\n  }\n\n  async readdir(dirname) {\n    const files = [];\n\n    for (const path in this.files) {\n      files.push(path);\n    }\n\n    return files;\n  }\n\n  async stat(path, options) {\n    const file = this.files[path];\n\n    if (!file) {\n      throw new Error(path);\n    }\n\n    return {\n      size: file.size\n    };\n  }\n\n  async unlink(path) {\n    delete this.files[path];\n    delete this.lowerCaseFiles[path];\n    this.usedFiles[path] = true;\n  }\n\n  async open(pathname, flags, mode) {\n    return this.files[pathname];\n  }\n\n  async read(fd, buffer) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : buffer.byteLength;\n    let position = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    const file = fd;\n    const startPosition = 0;\n    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();\n    return {\n      bytesRead: length,\n      buffer: arrayBuffer\n    };\n  }\n\n  async close(fd) {}\n\n  _getFile(path, used) {\n    const file = this.files[path] || this.lowerCaseFiles[path];\n\n    if (file && used) {\n      this.usedFiles[path] = true;\n    }\n\n    return file;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}