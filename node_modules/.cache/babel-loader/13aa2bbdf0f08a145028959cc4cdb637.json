{"ast":null,"code":"import { global, isBrowser as getIsBrowser } from 'probe.gl/env';\nimport { trackContextState } from '../state-tracker/track-context-state';\nimport { log } from '../utils/log';\nimport { assert } from '../utils/assert';\nimport { getDevicePixelRatio } from '../utils/device-pixels';\nimport { isWebGL2 } from '../utils/webgl-checks';\nconst isBrowser = getIsBrowser();\nconst isPage = isBrowser && typeof document !== 'undefined';\nconst CONTEXT_DEFAULTS = {\n  webgl2: true,\n  webgl1: true,\n  throwOnError: true,\n  manageState: true,\n  canvas: null,\n  debug: false,\n  width: 800,\n  height: 600\n};\nexport function createGLContext() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assert(isBrowser, \"createGLContext only available in the browser.\\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils\");\n  options = Object.assign({}, CONTEXT_DEFAULTS, options);\n  const {\n    width,\n    height\n  } = options;\n\n  function onError(message) {\n    if (options.throwOnError) {\n      throw new Error(message);\n    }\n\n    console.error(message);\n    return null;\n  }\n\n  options.onError = onError;\n  let gl;\n  const {\n    canvas\n  } = options;\n  const targetCanvas = getCanvas({\n    canvas,\n    width,\n    height,\n    onError\n  });\n  gl = createBrowserContext(targetCanvas, options);\n\n  if (!gl) {\n    return null;\n  }\n\n  gl = instrumentGLContext(gl, options);\n  logInfo(gl);\n  return gl;\n}\nexport function instrumentGLContext(gl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!gl || gl._instrumented) {\n    return gl;\n  }\n\n  gl._version = gl._version || getVersion(gl);\n  gl.luma = gl.luma || {};\n  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};\n  options = Object.assign({}, CONTEXT_DEFAULTS, options);\n  const {\n    manageState,\n    debug\n  } = options;\n\n  if (manageState) {\n    trackContextState(gl, {\n      copyState: false,\n      log: function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return log.log(1, ...args)();\n      }\n    });\n  }\n\n  if (isBrowser && debug) {\n    if (!global.makeDebugContext) {\n      log.warn('WebGL debug mode not activated. import \"@luma.gl/debug\" to enable.')();\n    } else {\n      gl = global.makeDebugContext(gl, options);\n      log.level = Math.max(log.level, 1);\n    }\n  }\n\n  gl._instrumented = true;\n  return gl;\n}\nexport function getContextDebugInfo(gl) {\n  const vendorMasked = gl.getParameter(7936);\n  const rendererMasked = gl.getParameter(7937);\n  const ext = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);\n  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);\n  return {\n    vendor: vendorUnmasked || vendorMasked,\n    renderer: rendererUnmasked || rendererMasked,\n    vendorMasked,\n    rendererMasked,\n    version: gl.getParameter(7938),\n    shadingLanguageVersion: gl.getParameter(35724)\n  };\n}\nexport function resizeGLContext(gl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (gl.canvas) {\n    const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);\n    setDevicePixelRatio(gl, devicePixelRatio, options);\n    return;\n  }\n\n  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');\n\n  if (ext && `width` in options && `height` in options) {\n    ext.resize(options.width, options.height);\n  }\n}\n\nfunction createBrowserContext(canvas, options) {\n  const {\n    onError\n  } = options;\n  let errorMessage = null;\n\n  const onCreateError = error => errorMessage = error.statusMessage || errorMessage;\n\n  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);\n  const {\n    webgl1 = true,\n    webgl2 = true\n  } = options;\n  let gl = null;\n\n  if (webgl2) {\n    gl = gl || canvas.getContext('webgl2', options);\n    gl = gl || canvas.getContext('experimental-webgl2', options);\n  }\n\n  if (webgl1) {\n    gl = gl || canvas.getContext('webgl', options);\n    gl = gl || canvas.getContext('experimental-webgl', options);\n  }\n\n  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);\n\n  if (!gl) {\n    return onError(`Failed to create ${webgl2 && !webgl1 ? 'WebGL2' : 'WebGL'} context: ${errorMessage || 'Unknown error'}`);\n  }\n\n  if (options.onContextLost) {\n    canvas.addEventListener('webglcontextlost', options.onContextLost, false);\n  }\n\n  if (options.onContextRestored) {\n    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);\n  }\n\n  return gl;\n}\n\nfunction getCanvas(_ref) {\n  let {\n    canvas,\n    width = 800,\n    height = 600,\n    onError\n  } = _ref;\n  let targetCanvas;\n\n  if (typeof canvas === 'string') {\n    const isPageLoaded = isPage && document.readyState === 'complete';\n\n    if (!isPageLoaded) {\n      onError(`createGLContext called on canvas '${canvas}' before page was loaded`);\n    }\n\n    targetCanvas = document.getElementById(canvas);\n  } else if (canvas) {\n    targetCanvas = canvas;\n  } else {\n    targetCanvas = document.createElement('canvas');\n    targetCanvas.id = 'lumagl-canvas';\n    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n    document.body.insertBefore(targetCanvas, document.body.firstChild);\n  }\n\n  return targetCanvas;\n}\n\nfunction logInfo(gl) {\n  const webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';\n  const info = getContextDebugInfo(gl);\n  const driver = info ? `(${info.vendor},${info.renderer})` : '';\n  const debug = gl.debug ? ' debug' : '';\n  log.info(1, `${webGL}${debug} context ${driver}`)();\n}\n\nfunction getVersion(gl) {\n  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n    return 2;\n  }\n\n  return 1;\n}\n\nfunction setDevicePixelRatio(gl, devicePixelRatio, options) {\n  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;\n  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;\n\n  if (!clientWidth || !clientHeight) {\n    log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n    devicePixelRatio = 1;\n    clientWidth = gl.canvas.width || 1;\n    clientHeight = gl.canvas.height || 1;\n  }\n\n  gl.luma = gl.luma || {};\n  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};\n  const cachedSize = gl.luma.canvasSizeInfo;\n\n  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {\n    let clampedPixelRatio = devicePixelRatio;\n    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n    gl.canvas.width = canvasWidth;\n    gl.canvas.height = canvasHeight;\n\n    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {\n      log.warn(`Device pixel ratio clamped`)();\n      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);\n      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);\n      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);\n    }\n\n    Object.assign(gl.luma.canvasSizeInfo, {\n      clientWidth,\n      clientHeight,\n      devicePixelRatio\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}