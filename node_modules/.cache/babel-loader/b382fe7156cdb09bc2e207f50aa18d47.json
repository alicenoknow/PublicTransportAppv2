{"ast":null,"code":"import Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport { copyUniform, checkUniformValues } from './uniforms';\nimport { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nimport { uid } from '../utils/utils';\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\nconst V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];\nexport default class Program extends Resource {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, props);\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n    this._isCached = false;\n    this.initialize(props);\n    Object.seal(this);\n\n    this._setId(props.id);\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      hash,\n      vs,\n      fs,\n      varyings,\n      bufferMode = GL_SEPARATE_ATTRIBS\n    } = props;\n    this.hash = hash || '';\n    this.vs = typeof vs === 'string' ? new VertexShader(this.gl, {\n      id: `${props.id}-vs`,\n      source: vs\n    }) : vs;\n    this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, {\n      id: `${props.id}-fs`,\n      source: fs\n    }) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n    this.uniforms = {};\n    this._textureUniforms = {};\n\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n\n    this._readUniformLocationsFromLinkedProgram();\n\n    this.configuration = new ProgramConfiguration(this);\n    return this.setProps(props);\n  }\n\n  delete() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._isCached) {\n      return this;\n    }\n\n    return super.delete(options);\n  }\n\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    return this;\n  }\n\n  draw(_ref) {\n    let {\n      logPriority,\n      drawMode = 4,\n      vertexCount,\n      offset = 0,\n      start,\n      end,\n      isIndexed = false,\n      indexType = 5123,\n      instanceCount = 0,\n      isInstanced = instanceCount > 0,\n      vertexArray = null,\n      transformFeedback,\n      framebuffer,\n      parameters = {},\n      uniforms,\n      samplers\n    } = _ref;\n\n    if (uniforms || samplers) {\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message = `mode=${getKey(this.gl, drawMode)} verts=${vertexCount} ` + `instances=${instanceCount} indexType=${getKey(this.gl, indexType)} ` + `isInstanced=${isInstanced} isIndexed=${isIndexed} ` + `Framebuffer=${fb}`;\n      log.log(logPriority, message)();\n    }\n\n    assert(vertexArray);\n    this.gl.useProgram(this.handle);\n\n    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {\n      return false;\n    }\n\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {\n          framebuffer\n        });\n      }\n\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this._bindTextures();\n\n      withParameters(this.gl, parameters, () => {\n        if (isIndexed && isInstanced) {\n          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n    return true;\n  }\n\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n\n    this.gl.useProgram(this.handle);\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n\n          if (textureUpdate) {\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n\n            const texture = value;\n            const {\n              textureIndex\n            } = uniformSetter;\n            texture.bind(textureIndex);\n            value = textureIndex;\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      texture.update();\n      texturesRenderable = texturesRenderable && texture.loaded;\n    }\n\n    return texturesRenderable;\n  }\n\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, 35663);\n\n      switch (type) {\n        case 35633:\n          opts.vs = new VertexShader({\n            handle: shaderHandle\n          });\n          break;\n\n        case 35632:\n          opts.fs = new FragmentShader({\n            handle: shaderHandle\n          });\n          break;\n\n        default:\n      }\n    }\n\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n\n      this.id = uid(programName);\n    }\n  }\n\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _compileAndLink() {\n    const {\n      gl\n    } = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n\n    if (gl.debug || log.level > 0) {\n      const linked = gl.getProgramParameter(this.handle, 35714);\n\n      if (!linked) {\n        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n\n      gl.validateProgram(this.handle);\n      const validated = gl.getProgramParameter(this.handle, 35715);\n\n      if (!validated) {\n        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n  }\n\n  _readUniformLocationsFromLinkedProgram() {\n    const {\n      gl\n    } = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(35718);\n\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {\n        name\n      } = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info);\n\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);\n          this._uniformSetters[`${name}[${l}]`] = getUniformSetter(gl, location, info);\n        }\n      }\n    }\n\n    this._textureIndexCounter = 0;\n  }\n\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n\n  getUniformBlockIndex(blockName) {\n    return this.gl2.getUniformBlockIndex(this.handle, blockName);\n  }\n\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}