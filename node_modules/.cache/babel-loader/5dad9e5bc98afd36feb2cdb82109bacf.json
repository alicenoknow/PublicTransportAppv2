{"ast":null,"code":"import { decomposeCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nconst ERR_ARGUMENT = 'UniformBufferLayout illegal argument';\nconst GL_FLOAT = 0x1406;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\nexport default class UniformBufferLayout {\n  constructor(layout) {\n    this.layout = {};\n    this.size = 0;\n\n    for (const key in layout) {\n      this._addUniform(key, layout[key]);\n    }\n\n    this.size += (4 - this.size % 4) % 4;\n    const data = new Float32Array(this.size);\n    this.typedArray = {\n      [GL_FLOAT]: data,\n      [GL_INT]: new Int32Array(data.buffer),\n      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)\n    };\n  }\n\n  getBytes() {\n    return this.size * 4;\n  }\n\n  getData() {\n    return this.typedArray[GL_FLOAT];\n  }\n\n  getSubData(index) {\n    let data;\n    let offset;\n\n    if (index === undefined) {\n      data = this.data;\n      offset = 0;\n    } else {\n      const begin = this.offsets[index];\n      const end = begin + this.sizes[index];\n      data = this.data.subarray(begin, end);\n      offset = begin * 4;\n    }\n\n    return {\n      data,\n      offset\n    };\n  }\n\n  setUniforms(values) {\n    for (const key in values) {\n      this._setValue(key, values[key]);\n    }\n\n    return this;\n  }\n\n  _setValue(key, value) {\n    const layout = this.layout[key];\n    assert(layout, 'UniformLayoutStd140 illegal argument');\n    const typedArray = this.typedArray[layout.type];\n\n    if (layout.size === 1) {\n      typedArray[layout.offset] = value;\n    } else {\n      typedArray.set(value, layout.offset);\n    }\n  }\n\n  _addUniform(key, uniformType) {\n    const typeAndComponents = decomposeCompositeGLType(uniformType);\n    assert(typeAndComponents, ERR_ARGUMENT);\n    const {\n      type,\n      components: count\n    } = typeAndComponents;\n    this.size = this._alignTo(this.size, count);\n    const offset = this.size;\n    this.size += count;\n    this.layout[key] = {\n      type,\n      size: count,\n      offset\n    };\n  }\n\n  _alignTo(size, count) {\n    switch (count) {\n      case 1:\n        return size;\n\n      case 2:\n        return size + size % 2;\n\n      default:\n        return size + (4 - size % 4) % 4;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}