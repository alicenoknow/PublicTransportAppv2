{"ast":null,"code":"import { isWebGL2, assertWebGL2Context, log } from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport { isObjectEmpty } from '../utils/utils';\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertWebGL2Context(gl);\n    super(gl, props);\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers() {\n    let buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n\n    const {\n      buffer,\n      byteSize,\n      byteOffset\n    } = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin() {\n    let primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.gl.bindTransformFeedback(36386, this.handle);\n\n    this._bindBuffers();\n\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n\n    this._unbindBuffers();\n\n    this.gl.bindTransformFeedback(36386, null);\n    return this;\n  }\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n\n    return {\n      buffer,\n      byteOffset,\n      byteSize\n    };\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {\n          buffer,\n          byteSize,\n          byteOffset\n        } = this._getBufferParams(this.buffers[bufferIndex]);\n\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer) {\n    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let byteSize = arguments.length > 3 ? arguments[3] : undefined;\n    const handle = buffer && buffer.handle;\n\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(35982, index, handle);\n    } else {\n      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(36386, this.handle);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}