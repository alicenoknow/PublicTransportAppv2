{"ast":null,"code":"import Pass from './pass';\nimport { clear, setParameters, withParameters, cssToDeviceRatio } from '@luma.gl/core';\nexport default class LayersPass extends Pass {\n  render(props) {\n    const gl = this.gl;\n    setParameters(gl, {\n      framebuffer: props.target\n    });\n    return this._drawLayers(props);\n  }\n\n  _drawLayers(props) {\n    const {\n      viewports,\n      views,\n      onViewportActive,\n      clearCanvas = true\n    } = props;\n    props.pass = props.pass || 'unknown';\n    const gl = this.gl;\n\n    if (clearCanvas) {\n      clearGLCanvas(gl);\n    }\n\n    const renderStats = [];\n\n    for (const viewportOrDescriptor of viewports) {\n      const viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;\n      const view = views && views[viewport.id];\n      onViewportActive(viewport);\n\n      const drawLayerParams = this._getDrawLayerParams(viewport, props);\n\n      props.view = view;\n      const subViewports = viewport.subViewports || [viewport];\n\n      for (const subViewport of subViewports) {\n        props.viewport = subViewport;\n\n        const stats = this._drawLayersInViewport(gl, props, drawLayerParams);\n\n        renderStats.push(stats);\n      }\n    }\n\n    return renderStats;\n  }\n\n  _getDrawLayerParams(viewport, _ref) {\n    let {\n      layers,\n      pass,\n      layerFilter,\n      effects,\n      moduleParameters\n    } = _ref;\n    const drawLayerParams = [];\n    const indexResolver = layerIndexResolver();\n    const drawContext = {\n      viewport,\n      isPicking: pass.startsWith('picking'),\n      renderPass: pass\n    };\n    const layerFilterCache = {};\n\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n\n      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n\n      const layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n      const layerParam = {\n        shouldDrawLayer,\n        layerRenderIndex\n      };\n\n      if (shouldDrawLayer) {\n        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);\n      }\n\n      drawLayerParams[layerIndex] = layerParam;\n    }\n\n    return drawLayerParams;\n  }\n\n  _drawLayersInViewport(gl, _ref2, drawLayerParams) {\n    let {\n      layers,\n      pass,\n      viewport,\n      view\n    } = _ref2;\n    const glViewport = getGLViewport(gl, {\n      viewport\n    });\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {\n        color: true,\n        depth: true\n      } : view.props.clear;\n      withParameters(gl, {\n        scissorTest: true,\n        scissor: glViewport\n      }, () => clear(gl, clearOpts));\n    }\n\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n    setParameters(gl, {\n      viewport: glViewport\n    });\n\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const {\n        shouldDrawLayer,\n        layerRenderIndex,\n        moduleParameters,\n        layerParameters\n      } = drawLayerParams[layerIndex];\n\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        renderStatus.visibleCount++;\n        moduleParameters.viewport = viewport;\n\n        try {\n          layer.drawLayer({\n            moduleParameters,\n            uniforms: {\n              layerIndex: layerRenderIndex\n            },\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, \"drawing \".concat(layer, \" to \").concat(pass));\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n\n  shouldDrawLayer(layer) {\n    return true;\n  }\n\n  getModuleParameters(layer, effects) {\n    return null;\n  }\n\n  getLayerParameters(layer, layerIndex) {\n    return layer.props.parameters;\n  }\n\n  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n    const shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;\n\n    if (!shouldDrawLayer) {\n      return false;\n    }\n\n    drawContext.layer = layer;\n    let parent = layer.parent;\n\n    while (parent) {\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n\n      drawContext.layer = parent;\n      parent = parent.parent;\n    }\n\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n\n    layer.activateViewport(drawContext.viewport);\n    return true;\n  }\n\n  _getModuleParameters(layer, effects, pass, overrides) {\n    const moduleParameters = Object.assign(Object.create(layer.props), {\n      autoWrapLongitude: layer.wrapLongitude,\n      viewport: layer.context.viewport,\n      mousePosition: layer.context.mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(this.gl)\n    });\n\n    if (effects) {\n      for (const effect of effects) {\n        Object.assign(moduleParameters, effect.getModuleParameters(layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n\n}\nexport function layerIndexResolver() {\n  let startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let layerIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const resolvers = {};\n\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n    let index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n\n  return resolveLayerIndex;\n}\n\nfunction getGLViewport(gl, _ref3) {\n  let {\n    viewport\n  } = _ref3;\n  const height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;\n  const dimensions = viewport;\n  const pixelRatio = cssToDeviceRatio(gl);\n  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\n\nfunction clearGLCanvas(gl) {\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  setParameters(gl, {\n    viewport: [0, 0, width, height]\n  });\n  gl.clear(16384 | 256);\n}","map":null,"metadata":{},"sourceType":"module"}