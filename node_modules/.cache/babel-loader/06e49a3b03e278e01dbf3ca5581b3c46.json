{"ast":null,"code":"import MathArray from './base/math-array';\nimport { checkNumber, checkVector } from '../lib/validators';\nimport assert from '../lib/assert';\nimport * as quat from 'gl-matrix/quat';\nimport * as vec4 from 'gl-matrix/vec4';\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\nexport default class Quaternion extends MathArray {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    super(-0, -0, -0, -0);\n\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  fromMatrix3(m) {\n    quat.fromMat3(this, m);\n    return this.check();\n  }\n\n  identity() {\n    quat.identity(this);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    quat.setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = checkNumber(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = checkNumber(value);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = checkNumber(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = checkNumber(value);\n  }\n\n  len() {\n    return quat.length(this);\n  }\n\n  lengthSquared() {\n    return quat.squaredLength(this);\n  }\n\n  dot(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.dot only takes one argument');\n    }\n\n    return quat.dot(this, a);\n  }\n\n  rotationTo(vectorA, vectorB) {\n    quat.rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  add(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.add only takes one argument');\n    }\n\n    quat.add(this, this, a);\n    return this.check();\n  }\n\n  calculateW() {\n    quat.calculateW(this, this);\n    return this.check();\n  }\n\n  conjugate() {\n    quat.conjugate(this, this);\n    return this.check();\n  }\n\n  invert() {\n    quat.invert(this, this);\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    quat.lerp(this, a, b, t);\n    return this.check();\n  }\n\n  multiplyRight(a, b) {\n    assert(!b);\n    quat.multiply(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a, b) {\n    assert(!b);\n    quat.multiply(this, a, this);\n    return this.check();\n  }\n\n  normalize() {\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n\n    if (length === 0) {\n      this[3] = 1;\n    }\n\n    return this.check();\n  }\n\n  rotateX(rad) {\n    quat.rotateX(this, this, rad);\n    return this.check();\n  }\n\n  rotateY(rad) {\n    quat.rotateY(this, this, rad);\n    return this.check();\n  }\n\n  rotateZ(rad) {\n    quat.rotateZ(this, this, rad);\n    return this.check();\n  }\n\n  scale(b) {\n    quat.scale(this, this, b);\n    return this.check();\n  }\n\n  slerp(start, target, ratio) {\n    switch (arguments.length) {\n      case 1:\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arguments[0]);\n        break;\n\n      case 2:\n        [target, ratio] = arguments;\n        start = this;\n        break;\n\n      default:\n    }\n\n    quat.slerp(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vector;\n    vec4.transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a, b) {\n    return this.multiplyLeft(a, b);\n  }\n\n  multiply(a, b) {\n    return this.multiplyRight(a, b);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}