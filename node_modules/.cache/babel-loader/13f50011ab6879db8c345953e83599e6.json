{"ast":null,"code":"import { getPassthroughFS } from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert, isObjectEmpty, getShaderVersion } from '@luma.gl/webgl';\nimport Model from '../lib/model';\nexport default class Transform {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  delete() {\n    const {\n      model,\n      bufferTransform,\n      textureTransform\n    } = this;\n\n    if (model) {\n      model.delete();\n    }\n\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      clearRenderTarget = true\n    } = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({\n        color: true\n      });\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n\n    assert(swapped, 'Nothing to swap');\n  }\n\n  getBuffer() {\n    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  getData() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n\n      if (data) {\n        return data;\n      }\n    }\n\n    return null;\n  }\n\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      gl\n    } = this;\n\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(gl, Object.assign({}, props, {\n      fs: props.fs || getPassthroughFS({\n        version: getShaderVersion(props.vs)\n      }),\n      id: props.id || 'transform-model',\n      drawMode: props.drawMode || 0,\n      vertexCount: props.elementCount\n    }));\n    this.bufferTransform && this.bufferTransform.setupResources({\n      model: this.model\n    });\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n\n    assert(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n\n    return updatedOpts;\n  }\n\n}\n\nfunction canCreateBufferTransform(props) {\n  if (!isObjectEmpty(props.feedbackBuffers) || !isObjectEmpty(props.feedbackMap) || props.varyings && props.varyings.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (!isObjectEmpty(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {\n    return true;\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"module"}