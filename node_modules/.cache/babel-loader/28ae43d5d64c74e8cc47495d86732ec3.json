{"ast":null,"code":"import { createElement, useRef, useState, useMemo, useEffect, useImperativeHandle, forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Deck } from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from './utils/use-isomorphic-layout-effect';\nimport extractJSXLayers from './utils/extract-jsx-layers';\nimport positionChildrenUnderViews from './utils/position-children-under-views';\nimport extractStyles from './utils/extract-styles';\n\nfunction getRefHandles(thisRef) {\n  const handles = {\n    pickObject: opts => thisRef.deck.pickObject(opts),\n    pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),\n    pickObjects: opts => thisRef.deck.pickObjects(opts)\n  };\n  Object.defineProperty(handles, 'deck', {\n    get: () => thisRef.deck\n  });\n  return handles;\n}\n\nfunction redrawDeck(thisRef) {\n  if (thisRef.redrawReason) {\n    thisRef.deck._drawLayers(thisRef.redrawReason);\n\n    thisRef.redrawReason = null;\n  }\n}\n\nfunction createDeckInstance(thisRef, props) {\n  const DeckClass = props.Deck || Deck;\n  const deck = new DeckClass({ ...props,\n    style: null,\n    width: '100%',\n    height: '100%',\n    _customRender: redrawReason => {\n      thisRef.redrawReason = redrawReason;\n      const viewports = deck.viewManager.getViewports();\n\n      if (thisRef.lastRenderedViewports !== viewports) {\n        thisRef.forceUpdate(v => v + 1);\n      } else {\n        redrawDeck(thisRef);\n      }\n    }\n  });\n  return deck;\n}\n\nconst DeckGL = forwardRef((props, ref) => {\n  const _thisRef = useRef({});\n\n  const thisRef = _thisRef.current;\n  const [version, setVersion] = useState(0);\n  thisRef.forceUpdate = setVersion;\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const jsxProps = useMemo(() => extractJSXLayers(props), [props.layers, props.views, props.children]);\n  let inRender = true;\n\n  const handleViewStateChange = params => {\n    if (inRender && props.viewState) {\n      thisRef.viewStateUpdateRequested = params;\n      return null;\n    }\n\n    thisRef.viewStateUpdateRequested = null;\n    return props.onViewStateChange(params);\n  };\n\n  const handleInteractionStateChange = params => {\n    if (inRender) {\n      thisRef.interactionStateUpdateRequested = params;\n    } else {\n      thisRef.interactionStateUpdateRequested = null;\n      props.onInteractionStateChange(params);\n    }\n  };\n\n  const deckProps = useMemo(() => {\n    const forwardProps = { ...props,\n      style: null,\n      width: '100%',\n      height: '100%',\n      layers: jsxProps.layers,\n      views: jsxProps.views,\n      onViewStateChange: handleViewStateChange,\n      onInteractionStateChange: handleInteractionStateChange\n    };\n\n    if (thisRef.deck) {\n      thisRef.deck.setProps(forwardProps);\n    }\n\n    return forwardProps;\n  }, [props]);\n  useEffect(() => {\n    thisRef.deck = createDeckInstance(thisRef, { ...deckProps,\n      parent: containerRef.current,\n      canvas: canvasRef.current\n    });\n    return () => thisRef.deck.finalize();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    redrawDeck(thisRef);\n    const {\n      viewStateUpdateRequested,\n      interactionStateUpdateRequested\n    } = thisRef;\n\n    if (viewStateUpdateRequested) {\n      handleViewStateChange(viewStateUpdateRequested);\n    }\n\n    if (interactionStateUpdateRequested) {\n      handleInteractionStateChange(interactionStateUpdateRequested);\n    }\n  });\n  useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n  const {\n    viewManager\n  } = thisRef.deck || {};\n  const currentViewports = viewManager && viewManager.getViewports();\n  const {\n    ContextProvider,\n    width,\n    height,\n    id,\n    style\n  } = props;\n  const {\n    containerStyle,\n    canvasStyle\n  } = useMemo(() => extractStyles({\n    width,\n    height,\n    style\n  }), [width, height, style]);\n\n  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || thisRef.version !== version) {\n    thisRef.lastRenderedViewports = currentViewports;\n    thisRef.version = version;\n    const childrenUnderViews = positionChildrenUnderViews({\n      children: jsxProps.children,\n      deck: thisRef.deck,\n      ContextProvider\n    });\n    const canvas = createElement('canvas', {\n      key: 'canvas',\n      id: id || 'deckgl-overlay',\n      ref: canvasRef,\n      style: canvasStyle\n    });\n    thisRef.control = createElement('div', {\n      id: \"\".concat(id || 'deckgl', \"-wrapper\"),\n      ref: containerRef,\n      style: containerStyle\n    }, [canvas, childrenUnderViews]);\n  }\n\n  inRender = false;\n  return thisRef.control;\n});\nDeckGL.propTypes = Deck.getPropTypes(PropTypes);\nDeckGL.defaultProps = Deck.defaultProps;\nexport default DeckGL;","map":null,"metadata":{},"sourceType":"module"}