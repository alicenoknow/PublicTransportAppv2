{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\nconst ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];\nconst ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];\nexport default class IcoSphereGeometry extends Geometry {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = uid('ico-sphere-geometry')\n    } = props;\n    const {\n      indices,\n      attributes\n    } = tesselateIcosaHedron(props);\n    super({ ...props,\n      id,\n      indices,\n      attributes: { ...attributes,\n        ...props.attributes\n      }\n    });\n  }\n\n}\n\nfunction tesselateIcosaHedron(props) {\n  const {\n    iterations = 0\n  } = props;\n  const PI = Math.PI;\n  const PI2 = PI * 2;\n  const positions = [...ICO_POSITIONS];\n  let indices = [...ICO_INDICES];\n  positions.push();\n  indices.push();\n\n  const getMiddlePoint = (() => {\n    const pointMemo = {};\n    return (i1, i2) => {\n      i1 *= 3;\n      i2 *= 3;\n      const mini = i1 < i2 ? i1 : i2;\n      const maxi = i1 > i2 ? i1 : i2;\n      const key = `${mini}|${maxi}`;\n\n      if (key in pointMemo) {\n        return pointMemo[key];\n      }\n\n      const x1 = positions[i1];\n      const y1 = positions[i1 + 1];\n      const z1 = positions[i1 + 2];\n      const x2 = positions[i2];\n      const y2 = positions[i2 + 1];\n      const z2 = positions[i2 + 2];\n      let xm = (x1 + x2) / 2;\n      let ym = (y1 + y2) / 2;\n      let zm = (z1 + z2) / 2;\n      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);\n      xm /= len;\n      ym /= len;\n      zm /= len;\n      positions.push(xm, ym, zm);\n      return pointMemo[key] = positions.length / 3 - 1;\n    };\n  })();\n\n  for (let i = 0; i < iterations; i++) {\n    const indices2 = [];\n\n    for (let j = 0; j < indices.length; j += 3) {\n      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);\n      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);\n      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);\n      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);\n    }\n\n    indices = indices2;\n  }\n\n  const normals = new Array(positions.length);\n  const texCoords = new Array(positions.length / 3 * 2);\n  const l = indices.length;\n\n  for (let i = l - 3; i >= 0; i -= 3) {\n    const i1 = indices[i + 0];\n    const i2 = indices[i + 1];\n    const i3 = indices[i + 2];\n    const in1 = i1 * 3;\n    const in2 = i2 * 3;\n    const in3 = i3 * 3;\n    const iu1 = i1 * 2;\n    const iu2 = i2 * 2;\n    const iu3 = i3 * 2;\n    const x1 = positions[in1 + 0];\n    const y1 = positions[in1 + 1];\n    const z1 = positions[in1 + 2];\n    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));\n    const phi1 = Math.atan2(y1, x1) + PI;\n    const v1 = theta1 / PI;\n    const u1 = 1 - phi1 / PI2;\n    const x2 = positions[in2 + 0];\n    const y2 = positions[in2 + 1];\n    const z2 = positions[in2 + 2];\n    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));\n    const phi2 = Math.atan2(y2, x2) + PI;\n    const v2 = theta2 / PI;\n    const u2 = 1 - phi2 / PI2;\n    const x3 = positions[in3 + 0];\n    const y3 = positions[in3 + 1];\n    const z3 = positions[in3 + 2];\n    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));\n    const phi3 = Math.atan2(y3, x3) + PI;\n    const v3 = theta3 / PI;\n    const u3 = 1 - phi3 / PI2;\n    const vec1 = [x3 - x2, y3 - y2, z3 - z2];\n    const vec2 = [x1 - x2, y1 - y2, z1 - z2];\n    const normal = new Vector3(vec1).cross(vec2).normalize();\n    let newIndex;\n\n    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {\n      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v1;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v2;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);\n      newIndex = positions.length / 3 - 1;\n      indices.push(newIndex);\n      texCoords[newIndex * 2 + 0] = 1;\n      texCoords[newIndex * 2 + 1] = v3;\n      normals[newIndex * 3 + 0] = normal.x;\n      normals[newIndex * 3 + 1] = normal.y;\n      normals[newIndex * 3 + 2] = normal.z;\n    }\n\n    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;\n    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;\n    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;\n    texCoords[iu1 + 0] = u1;\n    texCoords[iu1 + 1] = v1;\n    texCoords[iu2 + 0] = u2;\n    texCoords[iu2 + 1] = v2;\n    texCoords[iu3 + 0] = u3;\n    texCoords[iu3 + 1] = v3;\n  }\n\n  return {\n    indices: {\n      size: 1,\n      value: new Uint16Array(indices)\n    },\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: new Float32Array(positions)\n      },\n      NORMAL: {\n        size: 3,\n        value: new Float32Array(normals)\n      },\n      TEXCOORD_0: {\n        size: 2,\n        value: new Float32Array(texCoords)\n      }\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}