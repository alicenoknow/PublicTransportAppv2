{"ast":null,"code":"import { COORDINATE_SYSTEM, PROJECTION_MODE } from '../../lib/constants';\nimport project from '../project/project';\nimport { Vector3, Matrix4 } from 'math.gl';\nimport memoize from '../../utils/memoize';\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst vs = \"\\nconst int max_lights = 2;\\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\\nuniform vec4 shadow_uProjectCenters[max_lights];\\nuniform bool shadow_uDrawShadowMap;\\nuniform bool shadow_uUseShadowMap;\\nuniform int shadow_uLightId;\\nuniform float shadow_uLightCount;\\n\\nvarying vec3 shadow_vPosition[max_lights];\\n\\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\\n  if (shadow_uDrawShadowMap) {\\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\\n  }\\n  if (shadow_uUseShadowMap) {\\n    for (int i = 0; i < max_lights; i++) {\\n      if(i < int(shadow_uLightCount)) {\\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\\n      }\\n    }\\n  }\\n  return gl_Position;\\n}\\n\";\nconst fs = \"\\nconst int max_lights = 2;\\nuniform bool shadow_uDrawShadowMap;\\nuniform bool shadow_uUseShadowMap;\\nuniform sampler2D shadow_uShadowMap0;\\nuniform sampler2D shadow_uShadowMap1;\\nuniform vec4 shadow_uColor;\\nuniform float shadow_uLightCount;\\n\\nvarying vec3 shadow_vPosition[max_lights];\\n\\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\\n\\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\\n\\n  float z = dot(rgbaDepth, bitUnpackShift);\\n  return smoothstep(0.001, 0.01, position.z - z);\\n}\\n\\nvec4 shadow_filterShadowColor(vec4 color) {\\n  if (shadow_uDrawShadowMap) {\\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\\n    return rgbaDepth;\\n  }\\n  if (shadow_uUseShadowMap) {\\n    float shadowAlpha = 0.0;\\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\\n    if(shadow_uLightCount > 1.0) {\\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\\n    }\\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\\n\\n    return vec4(\\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\\n      blendedAlpha\\n    );\\n  }\\n  return color;\\n}\\n\";\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n\n  return [coord[0], coord[1], 0];\n}\n\nfunction getViewportCenterPosition(_ref) {\n  let {\n    viewport,\n    center\n  } = _ref;\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\n\nfunction getViewProjectionMatrices(_ref2) {\n  let {\n    viewport,\n    shadowMatrices\n  } = _ref2;\n  const projectionMatrices = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n\n  return projectionMatrices;\n}\n\nfunction createShadowUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const uniforms = {\n    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),\n    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    shadow_uLightId: opts.shadowLightId || 0,\n    shadow_uLightCount: opts.shadowMatrices.length\n  };\n  const center = getMemoizedViewportCenterPosition({\n    viewport: opts.viewport,\n    center: context.project_uCenter\n  });\n  const projectCenters = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: opts.viewport\n  }).slice();\n\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());\n\n    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[\"shadow_uViewProjectionMatrices[\".concat(i, \"]\")] = viewProjectionMatrices[i];\n    uniforms[\"shadow_uProjectCenters[\".concat(i, \"]\")] = projectCenters[i];\n\n    if (opts.shadowMaps && opts.shadowMaps.length > 0) {\n      uniforms[\"shadow_uShadowMap\".concat(i)] = opts.shadowMaps[i];\n    } else {\n      uniforms[\"shadow_uShadowMap\".concat(i)] = opts.dummyShadowMap;\n    }\n  }\n\n  return uniforms;\n}\n\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': \"\\n    position = shadow_setVertexPosition(geometry.position);\\n    \",\n    'fs:DECKGL_FILTER_COLOR': \"\\n    color = shadow_filterShadowColor(color);\\n    \"\n  },\n  getUniforms: function () {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {\n      const {\n        shadowEnabled = true\n      } = opts;\n      return shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0 ? createShadowUniforms(opts, context) : {\n        shadow_uDrawShadowMap: false,\n        shadow_uUseShadowMap: false\n      };\n    }\n\n    return {};\n  }\n};","map":null,"metadata":{},"sourceType":"module"}