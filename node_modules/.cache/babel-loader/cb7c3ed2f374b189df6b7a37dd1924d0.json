{"ast":null,"code":"import Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport { assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { flipRows, scalePixels } from '../webgl-utils/typed-array-utils';\nimport { getTypedArrayFromGLType, getGLTypeFromTypedArray } from '../webgl-utils/typed-array-utils';\nimport { glFormatToComponents, glTypeToBytes } from '../webgl-utils/format-utils';\nimport { toFramebuffer } from '../webgl-utils/texture-utils';\nimport { assert } from '../utils/assert';\nexport function readPixelsToArray(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = 6408\n  } = options;\n  let {\n    sourceAttachment = 36064,\n    target = null,\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options;\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  assert(framebuffer);\n  const {\n    gl,\n    handle,\n    attachments\n  } = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  if (sourceAttachment === 36064 && handle === null) {\n    sourceAttachment = 1028;\n  }\n\n  assert(attachments[sourceAttachment]);\n  sourceType = sourceType || attachments[sourceAttachment].type;\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n  const prevHandle = gl.bindFramebuffer(36160, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.bindFramebuffer(36160, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\nexport function readPixelsToBuffer(source, _ref) {\n  let {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = 6408,\n    target = null,\n    targetByteOffset = 0,\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = _ref;\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  const gl2 = assertWebGL2Context(framebuffer.gl);\n  sourceType = sourceType || (target ? target.type : 5121);\n\n  if (!target) {\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {\n      byteLength,\n      accessor: {\n        type: sourceType,\n        size: components\n      }\n    });\n  }\n\n  target.bind({\n    target: 35051\n  });\n  withParameters(gl2, {\n    framebuffer\n  }, () => {\n    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);\n  });\n  target.unbind({\n    target: 35051\n  });\n\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\nexport function copyToDataUrl(source) {\n  let {\n    sourceAttachment = 36064,\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let data = readPixelsToArray(source, {\n    sourceAttachment\n  });\n  let {\n    width,\n    height\n  } = source;\n\n  while (height > targetMaxHeight) {\n    ({\n      data,\n      width,\n      height\n    } = scalePixels({\n      data,\n      width,\n      height\n    }));\n  }\n\n  flipRows({\n    data,\n    width,\n    height\n  });\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n}\nexport function copyToImage(source) {\n  let {\n    sourceAttachment = 36064,\n    targetImage = null\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const dataUrl = copyToDataUrl(source, {\n    sourceAttachment\n  });\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\nexport function copyToTexture(source, target) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    targetMipmaplevel = 0,\n    targetInternalFormat = 6408\n  } = options;\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width,\n    height\n  } = options;\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  assert(framebuffer);\n  const {\n    gl,\n    handle\n  } = framebuffer;\n  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(36160, handle);\n  assert(target);\n  let texture = null;\n\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);\n  } else {\n    switch (target) {\n      case 3553:\n      case 34067:\n        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);\n        break;\n\n      case 35866:\n      case 32879:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);\n        break;\n\n      default:\n    }\n  }\n\n  if (texture) {\n    texture.unbind();\n  }\n\n  gl.bindFramebuffer(36160, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return texture;\n}\nexport function blit(source, target) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    sourceX0 = 0,\n    sourceY0 = 0,\n    targetX0 = 0,\n    targetY0 = 0,\n    color = true,\n    depth = false,\n    stencil = false,\n    filter = 9728\n  } = options;\n  let {\n    sourceX1,\n    sourceY1,\n    targetX1,\n    targetY1,\n    sourceAttachment = 36064,\n    mask = 0\n  } = options;\n  const {\n    framebuffer: srcFramebuffer,\n    deleteFramebuffer: deleteSrcFramebuffer\n  } = getFramebuffer(source);\n  const {\n    framebuffer: dstFramebuffer,\n    deleteFramebuffer: deleteDstFramebuffer\n  } = getFramebuffer(target);\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  const {\n    gl,\n    handle,\n    width,\n    height,\n    readBuffer\n  } = dstFramebuffer;\n  const gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === 36064) {\n    sourceAttachment = 1028;\n  }\n\n  if (color) {\n    mask |= 16384;\n  }\n\n  if (depth) {\n    mask |= 256;\n  }\n\n  if (stencil) {\n    mask |= 1024;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    if (mask & (256 | 1024)) {\n      mask = 16384;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n\n  assert(mask);\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n  const prevDrawHandle = gl.bindFramebuffer(36009, handle);\n  const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);\n  gl2.readBuffer(readBuffer);\n  gl2.bindFramebuffer(36008, prevReadHandle || null);\n  gl2.bindFramebuffer(36009, prevDrawHandle || null);\n\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {\n      framebuffer: toFramebuffer(source),\n      deleteFramebuffer: true\n    };\n  }\n\n  return {\n    framebuffer: source,\n    deleteFramebuffer: false\n  };\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n\n  type = type || 5121;\n  const ArrayType = getTypedArrayFromGLType(type, {\n    clamped: false\n  });\n  const components = glFormatToComponents(format);\n  return new ArrayType(width * height * components);\n}","map":null,"metadata":{},"sourceType":"module"}