{"ast":null,"code":"import log from '../utils/log';\nimport { createMat4, getCameraPosition, getFrustumPlanes } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals } from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from '../lib/constants';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst IDENTITY = createMat4();\nconst ZERO_VECTOR = [0, 0, 0];\nconst DEFAULT_ZOOM = 0;\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\nexport default class Viewport {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = null,\n      x = 0,\n      y = 0,\n      width = 1,\n      height = 1\n    } = opts;\n    this.id = id || this.constructor.displayName || 'viewport';\n    this.x = x;\n    this.y = y;\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n\n    this._initViewMatrix(opts);\n\n    this._initProjectionMatrix(opts);\n\n    this._initPixelMatrices();\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n\n    if (this === viewport) {\n      return true;\n    }\n\n    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);\n  }\n\n  project(xyz) {\n    let {\n      topLeft = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  unproject(xyz) {\n    let {\n      topLeft = true,\n      targetZ\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      return lngLatToWorld(xyz);\n    }\n\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n\n    return xyz;\n  }\n\n  getBounds() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n\n  getDistanceScales() {\n    let coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n\n    return this.distanceScales;\n  }\n\n  containsPixel(_ref) {\n    let {\n      x,\n      y,\n      width = 1,\n      height = 1\n    } = _ref;\n    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n  }\n\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n    return this._frustumPlanes;\n  }\n\n  panByPosition(coords, pixel) {\n    return null;\n  }\n\n  getCameraPosition() {\n    return this.cameraPosition;\n  }\n\n  getCameraDirection() {\n    return this.cameraDirection;\n  }\n\n  getCameraUp() {\n    return this.cameraUp;\n  }\n\n  _createProjectionMatrix(_ref2) {\n    let {\n      orthographic,\n      fovyRadians,\n      aspect,\n      focalDistance,\n      near,\n      far\n    } = _ref2;\n    return orthographic ? new Matrix4().orthographic({\n      fovy: fovyRadians,\n      aspect,\n      focalDistance,\n      near,\n      far\n    }) : new Matrix4().perspective({\n      fovy: fovyRadians,\n      aspect,\n      near,\n      far\n    });\n  }\n\n  _initViewMatrix(opts) {\n    const {\n      viewMatrix = IDENTITY,\n      longitude = null,\n      latitude = null,\n      zoom = null,\n      position = null,\n      modelMatrix = null,\n      focalDistance = 1,\n      distanceScales = null\n    } = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n    this.zoom = zoom;\n\n    if (!Number.isFinite(this.zoom)) {\n      this.zoom = this.isGeospatial ? getMeterZoom({\n        latitude\n      }) + Math.log2(focalDistance) : DEFAULT_ZOOM;\n    }\n\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n    this.distanceScales = this.isGeospatial ? getDistanceScales({\n      latitude,\n      longitude\n    }) : distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = focalDistance;\n    this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n    this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n    this.position = ZERO_VECTOR;\n    this.meterOffset = ZERO_VECTOR;\n\n    if (position) {\n      this.position = position;\n      this.modelMatrix = modelMatrix;\n      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n    }\n\n    if (this.isGeospatial) {\n      this.longitude = longitude;\n      this.latitude = latitude;\n      this.center = this._getCenterInWorld({\n        longitude,\n        latitude\n      });\n    } else {\n      this.center = position ? this.projectPosition(position) : [0, 0, 0];\n    }\n\n    this.viewMatrixUncentered = viewMatrix;\n    this.viewMatrix = new Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new Vector3(this.center || ZERO_VECTOR).negate());\n  }\n\n  _getCenterInWorld(_ref3) {\n    let {\n      longitude,\n      latitude\n    } = _ref3;\n    const {\n      meterOffset,\n      distanceScales\n    } = this;\n    const center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n\n    if (meterOffset) {\n      const commonPosition = new Vector3(meterOffset).scale(distanceScales.unitsPerMeter);\n      center.add(commonPosition);\n    }\n\n    return center;\n  }\n\n  _initProjectionMatrix(opts) {\n    const {\n      projectionMatrix = null,\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1,\n      far = 1000,\n      focalDistance = 1\n    } = opts;\n    this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({\n      orthographic,\n      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n      aspect: this.width / this.height,\n      focalDistance,\n      near,\n      far\n    });\n  }\n\n  _initPixelMatrices() {\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n    const viewportMatrix = createMat4();\n    const pixelProjectionMatrix = createMat4();\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.viewportMatrix = viewportMatrix;\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n    }\n  }\n\n}\nViewport.displayName = 'Viewport';","map":null,"metadata":{},"sourceType":"module"}