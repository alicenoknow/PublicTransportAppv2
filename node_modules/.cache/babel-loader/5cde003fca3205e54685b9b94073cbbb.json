{"ast":null,"code":"import Controller from './controller';\nimport ViewState from './view-state';\nimport { mod } from '../utils/math-utils';\nimport { Vector3, _SphericalCoordinates as SphericalCoordinates, clamp } from 'math.gl';\nconst MOVEMENT_SPEED = 20;\nconst DEFAULT_STATE = {\n  position: [0, 0, 0],\n  pitch: 0,\n  bearing: 0,\n  maxPitch: 90,\n  minPitch: -90\n};\n\nclass FirstPersonState extends ViewState {\n  constructor(_ref) {\n    let {\n      width,\n      height,\n      position = DEFAULT_STATE.position,\n      bearing = DEFAULT_STATE.bearing,\n      pitch = DEFAULT_STATE.pitch,\n      longitude,\n      latitude,\n      maxPitch = DEFAULT_STATE.maxPitch,\n      minPitch = DEFAULT_STATE.minPitch,\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startZoom\n    } = _ref;\n    super({\n      width,\n      height,\n      position,\n      bearing,\n      pitch,\n      longitude,\n      latitude,\n      maxPitch,\n      minPitch\n    });\n    this._state = {\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startZoom\n    };\n  }\n\n  getDirection() {\n    let use2D = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const spherical = new SphericalCoordinates({\n      bearing: this._viewportProps.bearing,\n      pitch: use2D ? 90 : 90 + this._viewportProps.pitch\n    });\n    const direction = spherical.toVector3().normalize();\n    return direction;\n  }\n\n  panStart() {\n    return this;\n  }\n\n  pan() {\n    return this;\n  }\n\n  panEnd() {\n    return this;\n  }\n\n  rotateStart(_ref2) {\n    let {\n      pos\n    } = _ref2;\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startBearing: this._viewportProps.bearing,\n      startPitch: this._viewportProps.pitch\n    });\n  }\n\n  rotate(_ref3) {\n    let {\n      pos,\n      deltaAngleX = 0,\n      deltaAngleY = 0\n    } = _ref3;\n    const {\n      startRotatePos,\n      startBearing,\n      startPitch\n    } = this._state;\n    const {\n      width,\n      height\n    } = this._viewportProps;\n\n    if (!startRotatePos || !Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {\n      return this;\n    }\n\n    let newRotation;\n\n    if (pos) {\n      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n      newRotation = {\n        bearing: startBearing - deltaScaleX * 180,\n        pitch: startPitch - deltaScaleY * 90\n      };\n    } else {\n      newRotation = {\n        bearing: startBearing - deltaAngleX,\n        pitch: startPitch - deltaAngleY\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotatePos: null,\n      startBearing: null,\n      startPitch: null\n    });\n  }\n\n  zoomStart() {\n    return this._getUpdatedState({\n      startZoomPosition: this._viewportProps.position,\n      startZoom: this._viewportProps.zoom\n    });\n  }\n\n  zoom(_ref4) {\n    let {\n      scale\n    } = _ref4;\n    let {\n      startZoomPosition\n    } = this._state;\n\n    if (!startZoomPosition) {\n      startZoomPosition = this._viewportProps.position;\n    }\n\n    const direction = this.getDirection();\n    return this._move(direction, Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);\n  }\n\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  moveLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: Math.PI / 2\n    }), speed);\n  }\n\n  moveRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: -Math.PI / 2\n    }), speed);\n  }\n\n  moveUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction, speed);\n  }\n\n  moveDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction.negate(), speed);\n  }\n\n  rotateLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      bearing: this._viewportProps.bearing - speed\n    });\n  }\n\n  rotateRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      bearing: this._viewportProps.bearing + speed\n    });\n  }\n\n  rotateUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      pitch: this._viewportProps.pitch + speed\n    });\n  }\n\n  rotateDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      pitch: this._viewportProps.pitch - speed\n    });\n  }\n\n  zoomIn() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this.zoom({\n      scale: speed\n    });\n  }\n\n  zoomOut() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this.zoom({\n      scale: 1 / speed\n    });\n  }\n\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = { ...this._viewportProps\n    };\n    const {\n      bearing,\n      longitude\n    } = props;\n\n    if (Math.abs(bearing - fromProps.bearing) > 180) {\n      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;\n    }\n\n    if (Math.abs(longitude - fromProps.longitude) > 180) {\n      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;\n    }\n\n    return props;\n  }\n\n  _move(direction, speed) {\n    let fromPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._viewportProps.position;\n    const delta = direction.scale(speed);\n    return this._getUpdatedState({\n      position: new Vector3(fromPosition).add(delta)\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    return new FirstPersonState({ ...this._viewportProps,\n      ...this._state,\n      ...newProps\n    });\n  }\n\n  _applyConstraints(props) {\n    const {\n      pitch,\n      maxPitch,\n      minPitch,\n      longitude,\n      bearing\n    } = props;\n    props.pitch = clamp(pitch, minPitch, maxPitch);\n\n    if (longitude < -180 || longitude > 180) {\n      props.longitude = mod(longitude + 180, 360) - 180;\n    }\n\n    if (bearing < -180 || bearing > 180) {\n      props.bearing = mod(bearing + 180, 360) - 180;\n    }\n\n    return props;\n  }\n\n}\n\nexport default class FirstPersonController extends Controller {\n  constructor(props) {\n    super(FirstPersonState, props);\n  }\n\n  get linearTransitionProps() {\n    return ['position', 'pitch', 'bearing'];\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}