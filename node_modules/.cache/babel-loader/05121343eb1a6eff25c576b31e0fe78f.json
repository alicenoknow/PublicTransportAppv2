{"ast":null,"code":"import Resource from './resource';\nimport { FEATURES, hasFeatures } from '../features';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert } from '../utils/assert';\nconst GL_QUERY_RESULT = 0x8866;\nconst GL_QUERY_RESULT_AVAILABLE = 0x8867;\nconst GL_TIME_ELAPSED_EXT = 0x88bf;\nconst GL_GPU_DISJOINT_EXT = 0x8fbb;\nconst GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;\nconst GL_ANY_SAMPLES_PASSED = 0x8c2f;\nconst GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;\nexport default class Query extends Resource {\n  static isSupported(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const webgl2 = isWebGL2(gl);\n    const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);\n    let supported = webgl2 || hasTimerQuery;\n\n    for (const key of opts) {\n      switch (key) {\n        case 'queries':\n          supported = supported && webgl2;\n          break;\n\n        case 'timers':\n          supported = supported && hasTimerQuery;\n          break;\n\n        default:\n          assert(false);\n      }\n    }\n\n    return supported;\n  }\n\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, opts);\n    this.target = null;\n    this._queryPending = false;\n    this._pollingPromise = null;\n    Object.seal(this);\n  }\n\n  beginTimeElapsedQuery() {\n    return this.begin(GL_TIME_ELAPSED_EXT);\n  }\n\n  beginOcclusionQuery() {\n    let {\n      conservative = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n  }\n\n  beginTransformFeedbackQuery() {\n    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n  }\n\n  begin(target) {\n    if (this._queryPending) {\n      return this;\n    }\n\n    this.target = target;\n    this.gl2.beginQuery(this.target, this.handle);\n    return this;\n  }\n\n  end() {\n    if (this._queryPending) {\n      return this;\n    }\n\n    if (this.target) {\n      this.gl2.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n\n    return this;\n  }\n\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n\n    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n\n    return resultAvailable;\n  }\n\n  isTimerDisjoint() {\n    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n\n  getResult() {\n    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);\n  }\n\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n\n  createPoll() {\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n\n    let counter = 0;\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n\n      requestAnimationFrame(poll);\n    });\n    return this._pollingPromise;\n  }\n\n  _createHandle() {\n    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;\n  }\n\n  _deleteHandle() {\n    this.gl2.deleteQuery(this.handle);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}